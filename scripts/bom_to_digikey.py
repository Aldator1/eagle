#!/usr/bin/env python
# -*- coding: utf-8 -*-

HELP = """
Convert an xls[x] bom to a digikey parts order spreadsheet.

Accepts no arguments.
"""

import sys

# Get all of the tricky packages out of the way
try:
	from sh import rm
except:
	print("You need to install the sh module.")
	print("https://github.com/amoffat/sh")
	sys.exit(1)

try:
	from sh import unoconv
	import sh
except:
	print("You must have unoconv installed to convert the bom.")
	print("sudo apt-get install unoconv")
	sys.exit(1)

try:
	import dataprint
except:
	print("You need to install the dataprint module.")
	print("sudo pip install dataprint")
	sys.exit(1)

import csv as csvr
from glob import glob
import os
import itertools
import re
import natsort


def query_yes_no(question, default="yes"):
    """Ask a yes/no question via raw_input() and return their answer.

    "question" is a string that is presented to the user.
    "default" is the presumed answer if the user just hits <Enter>.
        It must be "yes" (the default), "no" or None (meaning
        an answer is required of the user).

    The "answer" return value is True for "yes" or False for "no".
    """
    valid = {"yes": True, "y": True, "ye": True,
             "no": False, "n": False}
    if default is None:
        prompt = " [y/n] "
    elif default == "yes":
        prompt = " [Y/n] "
    elif default == "no":
        prompt = " [y/N] "
    else:
        raise ValueError("invalid default answer: '%s'" % default)

    while True:
        sys.stdout.write(question + prompt)
        choice = raw_input().lower()
        if default is not None and choice == '':
            return valid[default]
        elif choice in valid:
            return valid[choice]
        else:
            sys.stdout.write("Please respond with 'yes' or 'no' "
                             "(or 'y' or 'n').\n")

# Display the help if any arguments are provided.
if len(sys.argv) > 1:
	print(HELP)
	sys.exit(0)

header = """\"# Digikey order form\"
\"# Converted from {}\"
\"# Generated by bom_to_digikey.py\"
\"#\"
"""

boms = glob('*bom.xls*')

if len(boms) == 0:
	print("Could not find a bom to convert.")
	sys.exit(1)

for b in boms:
	# Get the root name
	base = os.path.splitext(b)[0]
	csv = '{}_digikey.csv'.format(base)

	# Check if csv and txt versions already exist
	if os.path.exists(csv):
		# Open it and determine if we created it. If we did, then I'm sure it's
		# fine to overwrite it. Otherwise, we probably shouldn't just overwrite
		# other people's files.
		with open(csv, 'r') as f:
		    print('Found existing {}'.format(csv))
                    if(query_yes_no("Would you like to overwrite it?")):
                        pass
                    else:
                        print("Okay, exiting");
                        sys.exit(1)

	# Convert the bom to csv
	bom_tries = 3
	while bom_tries > 0:
		try:
			unoconv('-f', 'csv', '-o', csv, b)
			break
		except sh.ErrorReturnCode:
			print('Unable to convert bom on this go. Will try again \
because that seems to fix it.')
		bom_tries -= 1
		if bom_tries == 0:
			# Failed to convert bom. Exclude it
			print('Converting bom to csv failed. Not much we can do now.')
			sys.exit(1)

	# Read in CSV
	csv_contents = ''
	with open(csv, 'r') as f:
		csv_contents = f.read()

	with open(csv, 'r') as f:
	        # Figure out where all the columns are there are
		csvreader = csvr.reader(f)
		columns = next(csvreader);
                try:
                    parts_column = columns.index('Part');
                except ValueError:
                    print("There must be a column called \"Part\" to execute this script. Exiting");
                    sys.exit(1);
                digikey_columns = [];
                try:
                    digikey_columns.append(columns.index('DIGIKEY'));
                except ValueError:
                    try:
                        digikey_columns.append(columns.index('DIGIKEY1'));
                    except ValueError:
                        print("There must be at least one column of \"DIGIKEY\" part numbers. Exiting");
                        sys.exit(1);
                try:
                    digikey_columns.append(columns.index('DIGIKEY2'));
                    digikey_columns.append(columns.index('DIGIKEY3'));
                    digikey_columns.append(columns.index('DIGIKEY4'));
                except ValueError:
                    pass


                #process the columns into a dictionary where digikey part is
                #the key and a list of part number is the value
                #keep another dictionary of qtys for each part
                parts = {};
                qtys = {}
                for part in csvreader:
                    for col in digikey_columns:
                        if part[col] in parts:
                            parts[part[col]].append(part[parts_column]);
                            qtys[part[col]] = qtys[part[col]] + 1;
                        else:
                            parts[part[col]] = [part[parts_column]];
                            qtys[part[col]] = 1;

                #for each part in the dictionary compress the part numbers
                #to put in the digikey reference field
                parts_with_refs = {}
                for part, ref_list in parts.iteritems():
                    #sort the list alphabetically
                    #this should group all the prefixes together
                    ref_list = natsort.natsorted(ref_list);
                    ref_string = ""
                    cur_prefix = ""
                    cur_num = 0;
                    first_num = 0;
                    for ref in ref_list:
                        #we are already processing that prefix, just add the number
                        print(ref);
                        if re.match("[[a-z]*0-9]*",ref).group(0) is cur_prefix:
                            num = int(re.match(".*?([0-9]+)$",ref).group(1));
                            if cur_num + 1 is num:
                                cur_num = num;
                            else:
                                ref_string = ref_string + (str(first_num)+"-"+str(cur_num)+",")
                                cur_num = num;
                                first_num = num;

                        else:
                            #finish up the older prefix
                            if cur_prefix is "":
                                pass
                            else:
                                if cur_num is first_num:
                                    ref_string = ref_string + str(cur_num)+" ";
                                else:
                                    ref_string = ref_string+(str(first_num)+"-"+str(cur_num)+" ");
                            #we need to start a new prefix
                            cur_prefix = re.match("[^0-9]*",ref).group(0);
                            ref_string = ref_string +  re.match("[^0-9]*",ref).group(0);
                            cur_num = int(re.match(".*?([0-9]+)$",ref).group(1));
                            first_num = int(re.match(".*?([0-9]+)$",ref).group(1));


                    if cur_num is first_num:
                        ref_string = ref_string + (str(cur_num));
                    else:
                        ref_string = ref_string + (str(first_num)+"-"+str(cur_num));

                    parts_with_refs[part] = ref_string;

                print(parts_with_refs);
                raw_input("waiting");




	## Make header block comply with github by adding commas
	#newheader = ""
	#for line in header.split('\n')[0:-1]:
	#	newheader += line + ','*(columns-1) + '\n'

	## Write back CSV
	#with open(csv, 'w') as f:
	#	# Add header to csv
	#	f.write(newheader.format(b))
	#	f.write(csv_contents)

